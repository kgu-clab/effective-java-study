### 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

- 자바에서 문제의 상황을 알리는 타입(throwable)
    1. 검사 예외
    2. 런타임 예외
    3. 에러

- 검사 예외
    - 호출하는 쪽에서 복구하리라 여겨지는 상황에서 사용
    - 따라서 프로그램 외부의 자원과 상호작용할 때 많이 사용됨
    - ex) IOException(입출력 예외), FileNotFoundException(파일 찾기 불가 예외)

    - 즉, API 설계자가 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구하는 것을 말함

- 비검사 throwable(예외)
    - 런타임 예외와 에러가 존재함
    - 두 가지 모두 프로그램에서 잡을 필요가 없거나 통상적으로 잡지 말아야 할 때 사용
      -*개발자 실수*로 발생하는 '버그'이므로 **굳이 잡을 필요가 없다(컴파일러가 강제하지 않는다)**고 보는 것
      -'잡지 말아야 한때'라는 것은, `NullPointerException` (경고등)이 뜨면 "왜 `text`가 `null`이지?" 하고 원인을 찾아 **버그를 고쳐야지(`if (text != null)` 등을 추가)**, `try-catch` (경고등 무시)로 덮지 말아야 할 때를 의
    - 프로그램에서 비검사 예외를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 손해가 더 많다는 뜻
    - 해당 throwable을 잡지 않고 적절한 오류 메시지를 보내며 중단됨

- 런타임 예외
    - 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용
    - 런타임 예외는 대부분 전제조건을 만족하지 못했을 때 발생
      전제 조건 위배란?
      →클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻
      →ex) 지정한 배열의 크기 밖의 인덱스에 접근하려 할 때 ‘ArrayIndexOutOfBoundsException’을 발생시킨다. 이는 전제조건이 지켜지지 않았다는 뜻
    - 문제: 복구할 수 있는 상황인지 프로그래밍 오류인지 명확하게 구분되지 않을 때도 존재
        - **1. 복구할 수 있는 상황** (호출자가 대응해야 하는 상황, 예: 파일 없음, 네트워크 끊김)
          → 검사 예외를 사용하라고 추천합니다.
        - **2. 프로그래밍 오류** (코드가 잘못됨, 즉 버그, 예: 배열 범위 초과, null 참조)
          → 런타임 예외를 사용하라고 추천합니다.

      +확신하기 어려울 땐 ‘비검사 예외’를 사용

- 에러
    - 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용
    - 비검사 throwable을 구현할 때, 해당 throwable은 모두 RuntimeException의 하위 클래스여야 함
      왜?
      →실제로는 단순 버그나 복구 가능한 문제일 수도 있는데, Error를 상속받게 되면 ‘복구 불가능한 시스템 다운’ 상황으로 오인할 수도 있기 때문
      →Error는 throw 문으로 직접 던지는 일도 없어야 한다.(단, AssertionError는 예외)
        - `Error`는 "JVM에 심각하고 치명적인 문제가 발생하여 더 이상 복구가 불가능하다"라는 의미로 JVM만이 사용하기로 예약된 신호이기 때문에 함부로 던질 수 없음
        - `AssertionError`는 `Error` 계층에 속한 예외 중 유일하게 JVM 시스템 오류가 아닌 ‘개발자의 논리적 오류’를 나타내기 위해 특별히 허용된 예외

- 검사 예외도 아니고 런타임 예외도 아닌 throwable은 만들 수는 있지만 이로울 게 없으니 사용하지 말자
    - throwable은 정상적인 검사 예외보다 나을 게 하나도 없으면서 API 사용자를 헷갈리게 할 뿐

- 예외의 메서드
    - 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는 데 쓰임
    - 예외의 메서드가 없다면 프로그래머들은 오류 메시지를 파싱해 정보를 빼내야 함⇒해당 방식은 비추
      비추하는 이유는?
      →throwable 클래스들은 대부분 오류 메시지 포맷을 상세히 기술하지 않아 JVM이나 릴리스에 따라 포맷이 달라질 수 있음.
      →따라서 메시지 문자열을 파싱해 얻은 코드는 깨지기 쉽고 다른 환경에서 동작하지 않을 수 있음
    - 정리: Throwable 클래스가 제공하는 ‘오류 메시지 문자열’을 파싱하는 행위는 지양해야 하며 대신 전용 메서드인 ‘예외의 메서드’를 사용하라

  -

```java
// 오류 메시지를 파싱해 정보를 빼내는 경우
//데이터를 꺼낼 전용 메서드가 없고, 메시지(String)에만 의존합니다.
class BadMachineException extends Exception {
    public BadMachineException(int shortfall) {
        // "300원이 부족합니다." 라는 문자열만 만듭니다.
        //이후 300이라는 수를 꺼내기 위해 문자열을 파싱해야 
        super("에러: " + shortfall + "원이 부족합니다.");
    }
}

//예외의 메서드를 사용하는 경우
class GoodMachineException extends Exception {
    
    // 1. 데이터를 저장할 전용 필드
    private final int shortfallAmount; 

    public GoodMachineException(int shortfall) {
        super("에러: " + shortfall + "원이 부족합니다."); // 메시지는 사람이 보라고 둠
        
        // 2. 데이터를 필드에 안전하게 저장
        this.shortfallAmount = shortfall;
    }

    // 이것이 바로 '예외의 메서드' (전용 Getter)
    // 데이터를 안전하게 꺼낼 수 있는 약속된 통로입니다.
    public int getShortfallAmount() {
        return this.shortfallAmount;
    }
}

```
- **나쁜 방식:** `String` 메시지를 → `split()` → `replace()` → `Integer.parseInt()`
- **좋은 방식:** `e.getShortfallAmount()` → `int` 데이터

  →'예외의 메서드'란,  `getShortfallAmount()`처럼 예외 상황에 대한 구체적인 데이터(숫자, 객체 등)를 `catch` 블록에 안전하게 전달하기 위해 개발자가 직접 정의하는 접근자 메서드를 의미합니다.
  (모든 예외의 메서드는 Throwable 클래스를 상속받음)


- 검사 예외-솔루션 메서드 함께 제공
    - 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생함
    - 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공해야 함
    - ex) 물건 구입 시 카드 잔고가 부족하여 검사 예외 발생→잔고가 얼마나 부족한지 알려주는 접근자 메서드를 제공해야 함이콘 추가

