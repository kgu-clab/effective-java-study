- 자바 8 이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 메서드를 추가할 수 없었다.
- 자바 8부터는 디폴트 메서드라는 것이 생겼지만, 자바 7 이전에는 이를 전혀 고려하지 않았기 때문에 여전히 문제가 생길 수 있다.

> 디폴트 메서드란
> default 키워드를 붙여서 메서드의 기본 구현을 인터페이스에서 제공할 수 있게 하는 메서드이다.

- 자바 라이브러리에서는 추가한 디폴드 메서드는 코드 품질이 높고 범용적이다.
- 하지만 모든 상황에서 불변식을 해치지 않는 디폴드 메서드를 만드는 것은 어려운 일이다.

```java
//자바 8의 컬렉션 인터페이스에 추가된 디폴트 메서드 removeIf
default boolean removelf(Predicate filter) {
	Objects.requireNonNull(filter);
	boolean result = false;
	for (Iterater it = iterator(); it.hasNext(); ) {
		if (filter.test(it.next())) {
			it. remove();
			result = true;
		}
	}
	return result;
	}
```
removeIf는 주어진 boolean함수(predicate)가 true를 반환하는 모든 원소를 제거한다.
해당 코드는 범용적이지만, 어떤 코드와는 어울리지 않는다.
예) org.apache.commons.collections4.collection.SynchronizedCollection
- 이 클래스는 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스이다.
- 해당 클래스는 removeIf 메서드를 재정의 하고 있지 않다.(현재 4.4 버전 이후로 추가)
- 만약 재정의 하지 않은 removeIf를 사용한다면, 해당 메서드는 동기화나 락 관련 기능을 전혀 제공해주지 못한다.
- 따라서 멀티 스레드 환경에서 removeIf를 활용했을 때 예기치 못한 결과를 낳을 수 있다.

> 락 객체란
> 멀티 스레드 환경에서 데이터의 일관성을 보장하기 위해 여러 스레드의 동시 접근을 방지하는 객체를 의미한다.

자바 플랫폼 라이브러리에서는 이를 방지하기 위해 Collections.SynchronizedCollection이 반환하는 package-private 클래스들은 removelf를 재정의하고, 이를 호출하는 다른 메서드들은 디폴트 구현을 호출하기 전에 동기화를 하도록 했다.

하지만 제3의 구현체들은 수정할 기회가 없었다.

## 주의할 점


- 디폴트 메서드로 새 메서드를 추가하는 것은 꼭 필요한 일이 아니면 피해야 한다.
- 추가할 때 역시 기존 구현체들과 충돌하지 않는지 여러번 고민해야 한다.
- 디폴트 메서드는 시그니처를 수정하거나 메서드를 삭제하기 위한 것이 아님을 명심해야 한다.

- 인터페이스를 설계할 때에는 주의를 기울여야 한다.
- 작은 결함도 사용자 시점에서는 문제가 될 수 있다.
- 반드시 인터페이스를 다른 방법으로 최소한 3번은 구현해 보아야 한다.
- 또한 인스턴스를 다양한 방법으로 활용하고 구현해 보아야 한다.
- 인터페이스를 릴리즈한 후에도 결함을 수정할 수는 있지만, 어디까지나 가능성이다.