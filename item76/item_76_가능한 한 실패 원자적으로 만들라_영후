- 작업 도중에 예외가 발생하더라도 해당 객체는 메서드의 호출 전 상태를 유지해야 한다.
- 이는 검사 예외를 던진 경우 호출자가 복구 후 재시도 할 수 있게 만드므로 더욱 유용할 것이다.
- 이러한 특성을 **실패 원자적**이라고 한다.

- 메서드를 실패 원자적으로 만드는 방법은 다양하다.

**불변 객체로 설계**
- 불변 객체는 태생적으로 실패 원자적이다
- 왜냐하면 불변 객체의 상태는 생성 시점에 고정된 후 절대 변하지 않기 때문이다.
- 따라서 새로운 객체가 만들어지지는 않지만, 그렇다고 불안정한 상태에 빠지지도 않는다.

**매개변수의 유효성 검사**
- 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은 매개수의 유효성을 검사하는 것이다.
```java
public Object pop() {
	if (size = 0)
		throw new EmptyStackException();
	Object result = elements[—size];
	elements [size] = null; // 다 쓴 참조 해제
	return result;
}
```
- 이 메서드에서는 size가 0인데 pop을 호출하면 예외를 던진다.
- 물론 굳이 throw을 하지 않아도 자연스레 터지지만, 이때는 OutOfBoundsException이 터지므로 상황과 어울리지 않는 오류이다.

- 계산을 해보기 전에는 유효성을 검사해볼 수 없는 경우, 객체의 상태를 바꾸는 코드 앞에 실패할 가능성이 있는 모든 코드들을 배치하는 방법을 생각해볼 수 있다.
	- TreeMap이 예로, 만약 어떤 원소를 TreeMap에 추가하려고 한다면 트리를 변경하기에 앞서 원소의 위치를 찾을 때 오류가 날 것이다.

**객체의 임시 복사**
- 객체의 임시 복사본에서 작업을 수행한 후, 만약 성공한다면 원래 객체와 교체하는 방법이다.
- 예를 들어 어떤 정렬메서드는 리스트의 원소를 배열로 옮긴 후 알고리즘을 수행한다.
- 이는 배열을 통해 성능을 올리기 위한 것이지만, 실패 원자성 역시 보장할 수 있다는 효과가 있다.

**실패 가로채기**
- 작업 도중 실패가 발생하면, 이를 가로채고 복구하는 코드를 작성해 되돌리는 방법이다.
- 주로 디스크 기반의, 내구성을 보장해야 하는 자료구조에 쓰이는데, 여러 단점들이 있어 자주 쓰이는 방법은 아니다.

- 실패 원자성은 지키는 것이 좋지만, 그렇지 못하는 경우도 존재한다.
- 두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면, 그 객체는 일관성이 깨질 수 있다.
	- 이런 경우 예외를 잡았다고 객체를 복구시키는건 어렵다.
- 실패 원자적으로 만들 수 있지만, 이를 위한 비용이나 복잡도가 매우 큰 경우도 있을 수 있다.
	- 물론 문제 상황을 알면 실패 원자성은 손쉽게 얻을 수 있는 경우가 더 많다.

- 메서드 명세에 기술한 예외는 실패 원자성을 보장해야 한다
- 만약 그렇지 못하다면 이때의 객체 상태를 명세해야 한다.
- 하지만 대부분의 API 문서는 이를 지키지 않고 있다.