- 검사 예외는 발생한 문제를 프로그래머가 직접 처리하도록 만들어 안전성을 높일 수 있다.
- 하지만 검사 예외를 과하게 사용하는 것은 오히려 불편한 API를 만든다.
	- 검사 예외를 두면, catch문을 두거나 문제를 바깥으로 전파해야만 한다.
	- 또한 이러한 메서드는 스트림 안에서는 사용할 수 없어 불편하다.
- API를 제대로 사용하더라도 발생할 수 있는 예외이거나, 프로그래머가 조치를 적절히 취할 수 있는 예외는 검사 예외를 두는 것이 좋다.
- 하지만 그렇지 않다면 비검사 예외를 사용하는 것이 좋다.


```java
} catch (TheCheckedException e) {
    throw new AssertionError(); // 일어날 수 없다!
}
```
- 위와 같은 처리가 전부라면 검사 예외는 굳이 필요 없을 것이다.

```java
} catch (TheCheckedException e) {
    e.printStackTrace(); // 이런, 우리가 졌다.
    System.exit(1);
}
```
- 이 코드도 마찬가지로 시스템을 중단할 뿐이므로, 별 의미가 없다.
- 더 나은 방법이 없다면 비검사 예외를 선택해야 한다.
- 특히 처리해야 할 검사 예외가 단 하나 뿐이라면, API 사용자는 오롯이 그 예외를 위해 위의 단점들을 껴안고 가야 한다.

### 해결 방법

- **검사 예외를 회피하는 가장 쉬운 방법은 옵셔널을 반환하는 것이다.**
	- 검사 예외를 던지는 대신 빈 옵셔널을 반환하면 된다.
	- 다만 예외 이유를 알 수 없다는 단점이 있다.



- **다른 방법은 검사 예외를 던지는 메서드를 2개로 쪼갠 후 비검사 예외로 바꿀 수 있다.**
```java
try {
	obj.action(args);
} catch (TheCheckedException e) {
	... // 예외 상황에 대처한다.
}
```

```java
if (obj.actionPermitted(args)) {
	obj.action(args);
} else {
	... // 예외 상황에 대처한다.
}
```
- 상태 검사 메서드와 비검사 예외를 던지는 메서드로 쪼개었다.
- 이 방식이 더 이쁘진 않지만, 더 유연하다.
- 이 방식은 만약 프로그래머가 성공함을 확신하거나, 스레드 중단을 원한다면 if else문을 제거해도 무방하다.
- 한편 상태 검사 메서드는 몇가지 단점도 존재한다.
	- 두 메서드의 호출 사이에 객체의 상태가 변할 수 있다.
	- 즉 여러 스레드의 동시 접근이 가능하거나 외부 요인에 의한 상태 변화가 가능하다면 적절치 않다.
	- 상태 검사 메서드가 실행 메서드의 일부를 중복 수행한다면 역시 이 적절하지 않을수도 있다.

> 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다. API 호출자가 예외 상황에서 복구할 방법이 없다면 비검 사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.