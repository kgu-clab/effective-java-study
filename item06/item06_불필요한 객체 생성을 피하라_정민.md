### 불필요한 객체 생성을 피하라

“똑같은 기능을 가진 객체가 있다면 객체 하나를 재사용하는 것이 낫다.”

- 비교 예시 1) 사용하지 말 것

    ```java
    String s = new String("bikini");
    ```

  →호출마다 String 객체가 새로 만들어진다.

  비교 예시2) 대신 사용할 것

    ```java
    String s = "bikini";
    ```

  →매번 객체를 만드는 대신 하나의 String 객체를 사용한다.


- 불필요한 객체 생성을 피하는 방법
  :생성자 대신 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.
  *정적 팩터리 메서드: 생성자(new) 대신 static 메서드로 객체를 생성하여 반환하는 메서드

  :예시)
  Boolean(String) 대신 Boolean.valueOf(String) 사용
  → 정적 팩터리 메서드인 valueOf()를 호출해 객체를 생성함

  (String 타입을 Boolean 타입으로 변환해줌)

  :이유)
  생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 그렇지 않기 때문에

- 객체 생성을 최소화 해야하는 경우
  :생성 비용이 비싼 객체에 대해서는 해당 객체가 반복해서 필요할 때 캐싱하여 재사용하길 권한다.
  *캐싱: 이미 생성된 것을 저장해두고 재사용하는 것
  *문제점: 자신이 만드는 객체가 비싼 객체인지 매번 명확히 알 수는 없음
  :비교 예시1)

    ```java
    static boolean isRomanNumeral(String s) {
    return s.matches("시?=. )M*(C[M 미 |D?C{0,3})"
    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }
    ```

  →Pattern 인스턴스는 한 번 쓰고 버려져서 객체 호출마다 내부적으로 Pattern 객체를 새로 생성함(유한 상태 머신을 만듦). 따라서 인스턴스 생성 비용이 높음
  :비교 예시2)

    ```java
    public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
    "스(?=.)M *(C[MD]|D?C{0,3})"
    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    static boolean isRomanNumeral(String s) {
    return ROMAN.matcher(s).matches();
    }
    }
    ```

  →정규 표현식을 표현하는 불변 Pattern 인스턴스를 클래스 초기화 과정에서 정적 멤버 변수로 직접 생성해 캐싱해둔다. 나중에 메서드가 호출될 때마다 해당 인스턴스를 재사용한다.

  →추가 기능: 존재조차 몰랐던 Pattern 인스턴스를 static final 필드(정적 멤버 변수)로 정의해주며 코드의 의미가 잘 드러나게 됨

  →가질 수 있는 의문)
  Q)클래스가 초기화 된 후 이 메서드를 한 번도 호출하지 않는다면 ROMAN 필드는 쓸데없이 초기화 된 꼴 아닌가?
  A) 이 문제는 ‘지연 초기화’로 불필요한 초기화를 없애 해결할 수 있지만 코드를 복잡하게 만들며 성능은 크게 개선되지 않을 때가 많아 권장하지 않음

- 그럼 객체가 불변일 때는 무조건 재사용해야하는가? 아닌 경우 존재
  (즉, 재사용시의 안전함이 덜 명확하거나 직관에 반대되는 상황 존재)
  →어댑터
  :실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체
  :뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분함
  :예시) Map 인터페이스의 keySet 메서드
  →Map 객체 안의 키 전부를 담은 Set 뷰를 반환하는 기능을 함
  →keySet이 뷰 객체를 여러 개 만들어도 모두 똑같은 Map 인스턴스를 대변하기에 상관은 없지만 굳이 그럴 필요는 없음

- 불필요한 객체를 만들어내는 예시
→오토박싱(auto-boxing)
: 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술

    ```java
    public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
    "스(?=.)M *(C[MD]|D?C{0,3})"
    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    static boolean isRomanNume ral(String s) {
    return ROMAN.matcher(s).matches();
    }
    }
    ```
    
    →sum 변수를 long (기본타입)이 아닌 Long(참조타입)으로 선언해서 불필요한 Long 인스턴스가 약 2의 31승개나 쓸데없이 만들어짐
     (auto-boxing이 일어나게 하여 long 타입을 Long 타입으로 변환하는 데에 시간을 소비하게 함)
    →sum 타입을 long으로만 바꾸어주면 해결
    *박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의

- “단순히 객체 생성을 피하고자 자신만의 객체 풀(pool)을 만들지는 말자”
  →인스턴스 생성 비용이 비싼 경우 객체 풀을 마드는 것이 더 나을 수도 있지만 일반적으로는 코드를 헷갈리게 하고 메모리 사용량을 늘려 성능을 떨어뜨림
  →요즘 JVM의 가비지 컬렉터가 잘 최적화되어 있어 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠름

- 방어적 복사 vs 필요 없는 객체의 반복 생성
  :’기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라’
  vs
  ’새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라’
  *방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가, 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 더 큼

