# item15 : 클래스와 멤버의 접근 권한을 최소화하라

## 컴포넌트의 완성도를 가르는 것
- 클래스 내부 데이터, 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐
    - 구현과 API를 깔끔히 분리함.

오직 API를 통해서만 다른 컴포넌트와 소통, 서로 내부 동작 방식은 전혀 개의치 않음. 
- 정보 은닉 / 캡슐화 라고 불리기도 한다.

## 정보 은닉의 장점
- 시스템 개발 속도를 높임
  - 여러 컴포넌트를 병렬로 개발할 수 있기 때문
- 시스템 관리 비용을 낮춤
  - 각 컴포넌트를 더 빨리  파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문
- 성능을 높이진 않지만, 최적화에 도움.
  - 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정하고 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있기 때문
- 소프트웨어 재사용성을 높임
  - 외부에 의존하지 않고 독자적으로 동작하는 컴포넌트는 낮선 환경에서도 유용하게 쓰일 가능성이 큼
- 큰 시스템 제작 난이도를 낮춰줌
  - 시스템 전체가 아직 완성되지 않아도 개별 컴포넌트의 동작을 검증할 수 있음

## 정보 은닉 장치
제어 매커니즘 : 클래스, 인터페이스, 멤버 접근성을 명시. (접근성은 선언된 위치와 접근 제한자로 정해짐)
'접근 제한자를 제대로 활용하는 것' 이 정보 은닉의 핵심

## 기본 원칙
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함
  - 소프트웨어가 올바로 동작하는 선에서 가장 낮은 접근 수준을 부여해야 한다.
  - 톱레벨 클래스, 인터페이스에 부여할 수 있는 접근 수준은 package-private(default)와 public 두가지다.
  - public 선언 ⇒ 공개 API ⇒ 하위 호환을 위해 영원히 관리해야 함
  - package-private 선언 ⇒ 해당 패키지 안에서만 이용. ⇒ API가 아닌 내부구현이 되어 언제든 수정 가능. ⇒ 클라이언트에 피해 없이 다음 릴리스에서 수정, 교체, 제거 가능

## 공개 API를 세심히 설계 후 그 외의 모든 멤버는 private로 만들자.
- 이후 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한해 package-private로 풀어주자.
- 권한을 풀어주며 시스템에서 ‘컴포넌트를 더 분해해야 하는 것은 아닌지’ 다시 고민해보자.
- public, package-private 멤버는 모두 클래스 구현에 해당하므로 ‘보통은’ 공개 API에 영향을 주지 않는다.
  - 단, Serializable(직렬화!)을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다.

## 멤버 접근성을 좁히지 못하는 제약
- 상위 클래스의 메소드를 재정의 할 때 접근 수준을 상위 클래스보다 좁게 설정할 수 없다.
  - 규칙을 어기면 하위 클래스에서 컴파일 오류가 발생
- ⇒ 이 때, 클래스는 인터페이스가 정의한 모든 메소드를 public으로 선언해야 한다.

## public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면

- 필드 값 제한을 하지 못함 (불변식이 보장되지 않음)

- 필드가 수정될 때 (락 휙득 같은) 다른 작업을 할수 없게 됨 = ‘public 가변 필드’를 갖는 클래스는 일반적으로 스레드 안전하지 않다. (여러 작업이 동시에 특정 객체를 사용할 때 해당 객체의 상태가 꼬일 수 있음)


## 정적 필드에서도 마찬가지
예외가 한가지 존재한다.

해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로서의 상수라면
-  public static final 필드로 공개해도 좋다. 관례상 이런 상수 이름은 대문자 알파벳으로 쓰며, 각 단어 사이에 밑줄을 넣는다. 이런 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.
-  불변 객체가 아닌 가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용됨. 다른 객체를 참조할 수는 없지만, 참조된 객체 자체는 수정될 수 있음.. ⇒ 끔찍한 결과를 초래 !!

## 길이가 0이 아닌 배열은 모두 변경 가능하니 주의
클래스에서 public static final 배열 필드를 두거나 or 이 필드를 반환하는 접근자 메소드를 제공해서는 안됨
만약 제공한다면 클라이언트에서 배열의 내용을 수정할 수 있으니 주의!!

### 해결책
1. 불변 컬렉션 패턴
- 컬렉션 자체가 불변일 필요가 있을 때, 코드 안정성이 중요할 때
2. 방어적 복사
- 외부 입력값 보호가 필요할 때, 성능과 메모리 비용이 중요할 때


# 핵심정리 및 요약
- 잘 설계된 컴포넌트는 정보은닉 / 캡슐화를 통해 모든 내부 구현을 완벽히 숨김으로써 구현과 API를 깔끔히 분리한다.
  - 정보은닉의 핵심은 접근 제한자를 제대로 활용하는 것!
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀보자. 꼭 필요한 것만 골라 최소한의 public API를 설계하자.
- public 클래스는 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다
  - 불변식이 보장되지 않고 스레드 안전하지 않기 때문
- public static final 필드가 참조하는 객체가 '불변'인지 확인하라. 불변이 아니라면
  - 불변 컬렉션 패턴
  - 방어적 복사를 고려하라.

# 한줄요약
## 될수 있는 한 최대한 접근제한자의 범위를 좁히자.
