### 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 메서드와 정적 필드만을 담은 클래스(유틸리티 클래스)의 부정적 측면
  :상속이나 다형성 같은 객체 지향의 이점을 활용하지 않는 것이기 때문에 객체 지향 언어인 자바의 관점에서는 부정적인 면이 있음

- 정적 메서드와 정적 필드의 활용도
    1. java.lang.Math/ java.util.Arrays
       : 정적 메서드를 통해 정의되어, 객체 없이도 사용할 수 있음
       2. java.util.Collections
       : 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드를 모아 놓을 수 있게 함
       →인터페이스는 객체 생성이 안되지만, 그런 인터페이스를 구현한 객체를 생성하는 메서드들을 모아 놓은 클래스로 활용 가능
       3. final 클래스와 관련된 메서드들
       : final 클래스는 상속이 불가한데, 별도의 정적 유틸리티 클래스를 만들어 final 클래스와 관련된 기능을 확장해 사용 가능

⇒이러한 유틸리티 클래스들은 new 키워드를 통해 인스턴스를 생성할 필요가 없음!

- “생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어 준다.”
  위에서 설명한 활동도와 같이 new를 통해 인스턴스를 생성하지 않고 사용해도 되는 클래스에 대해서 컴파일러는 자동으로 기본 생성자를 불러와 객체를 만들어 줌
  ⇒즉, 의도치 않게 인스턴스화 할 수 있게 된 유틸리티 클래스가 존재함

- 그럼 추상 클래스로 인스턴스화를 막으면?
  추상클래스를 사용하면 객체 생성이 불가한 특성으로 인해 직접 인스턴스 생성을 막을 수 있을 것 같지만!
  하위 클래스가 상속받아 객체를 만들 수 있기 때문에 완전히 막는 것 불가
- 그렇다면 인스턴스화를 막는 법
  ⇒명시적으로 private 생성자를 만들어 줌
  (기본 생성자가 만들어지는 경우는 명시된 생성자가 없을  때 뿐이므로)

예제 코드

<aside>
💡

```java
public class UtilityClass {
    private UtilityClass() {
        throw new AssertionError();
    }
}
```

</aside>

→명시적으로 작성한 생성자가 private이니 클래스 바깥에서는 접근할 수 없음

→또한 ‘throw new AssertionError’를 통해 클래스 내부에서도 실수로 호출할 시 에러를 강제로 발생시킴

⇒즉, 어떤 경우에서도 클래스가 인스턴스화 되는 것을 막을 수 있음

- 주석을 달아 설명
  코드를 봤을 때 생성자가 눈에 보이는데 사용을 못하니까 초보자에게는 낯설거나 이상하게 느껴질 수 있음⇒주석을 통해 표시해두면 좋음
- 이러한 방법은 상속을 불가능하게 하는 효과도 있음
  하위 클래스는 반드시 상위 클래스의 생성자를 호출해야 슈퍼 클래스의 상속을 받을 수 있음
  ⇒하지만 private으로 인해 생성자 호출이 불가하게 됨
  ⇒상속 자체가 차단되는 효과를 가져옴

<aside>
💡

질문!
왜 객체 생성과 상속이 불가하게 만드려고 할까?
⇒유틸리티 클래스는 객체를 만들어도 의미가 없음→즉 메모리 낭비
⇒API를 사용하는 쪽에서 “객체를 만들어서 쓰는건가?”하고 잘못된 사용법을 유도하게 될 수도 있음

⇒상속은 기능 확장과 특수화가 목적인데 확장할 대상이 없는 유틸리티 클래스는 그 의도에 맞지 않음
⇒하위 클래스에서 의도에 맞지 않게 정적 메서드를 인스턴스 메서드처럼 사용하게 될 수도 있음

리플렉션 또한 AssertionError()로 방지 가능

</aside>