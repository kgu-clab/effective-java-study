### item 51:메서드 시그니처를 신중히 설계하라
→개별 아이템으로 두기 애매한 "API 설계 요령들"을 모아둔 아이템

- 메서드 이름을 신중히 짓자

  →항상 표준 명명 규칙을 따라야 함
    1.  이해할 수 있고 같은 패키지에 속한 다른 이름들과 일관되게 지어야 함
    2. 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용해야 함
    3. 긴 이름은 피해야 함
    4. 애매하면 자바 라이브러리의 API 가이드를 참조하라


- 편의 메서드를 너무 많이 만들지 말자
  →메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어려움
  →인터페이스도 마찬가지임
  →클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 함
  →아주 자주 쓰일 ‘예외의 경우’에만 약칭 메서드를 둔다
  (이것 마저도 확신이 서지 않으면 만들지 말아라)

- 매개변수 목록은 짧게 유지하자(4개 이하가 좋다)
  →만든 API에 매개변수 목록이 4개가 넘어가는 메서드가 많다면, 프로그래머들은 API 문서를 옆에 끼고 개발해야 함
  →같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해로움
  (컴파일과 실행은 되는데, 의도와 다르게 동작할 수 있음)

→긴 매개변수 목록을 짧게 줄여주는 기술
1. 여러 메서드로 쪼갠다.
   (잘못하면 메서드가 너무 많아질 수 있지만, **직교성을 높여** 오히려 메서드 수를 줄여주는 효과가 있음)
   (java.util.List 인터페이스를 예시로 들면, List는 부분리스트를 반환하는 subList 메서드와 주어진 원소의 인덱스를 알려주는 indexOf 메서드를 별개로 제공함→결과적으로 두 메서드를 잘 조합하여 사용하면 원하는 목적을 이루면서도 유연하게 사용가능함)

<aside>
💡

***직교성이 높다?**
→공통점이 없는 기능들이 잘 분리되어 있다
→기능을 원자적으로 쪼개 제공한다.

→like List ‘부분 리스트 얻기’와 ‘주어진 원소의 인덱스 구하기’는 서로 관련이 없으므로 두 기능을 개별 메서드로 제공하게 되면 ‘직교성이 높다’라고 볼 수 있음

→직교성이 높은 설계는 가볍고 구현하기 쉽고 유연하고 강력함
***직교성을 높여 오히려 메서드 수를 줄여주는 효과도 있다?(메서드가 쪼개졌는데 오히려 수가 줄어?)**
→예를 들면 기능 3개로 조합할 수 있는 기능은 총 7가지나 됨(오히려 복잡한 기능들을 추가하게 될 시 엄청난 크기의 API가 만들어질 수도 있음) 하지만 기능을 원자적으로 쪼개면 (1)중복이 줄고 (2)결합성이 낮아져 코드를 수정하기가 수월하고 (3)테스트하기도 쉬워짐
***무작정 작게 나누는게 답은 아님**
→특정 조합의 패턴이 상당히 자주 사용되거나 최적화하여 성능을 크게 개선할 수 있다면 직교성이 낮아지더라도 편의기능으로 제공하는 편이 나을수도 있음

</aside>

1. 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다.
   →잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 때 추천하는 기법
   →몇 개의 매개변수를 묶는 도우미 클래스를 만들어 하나의 매개변수로 주고받으면 API는 물론 클래스 내부 구현도 깔끔해짐
2. 앞서의 두 기법을 혼합한다.
   →매개변수가 많을 때, 그 중 일부는 생략해도 괜찮을 때 추천하는 기법
1. 모든 매개변수를 하나로 추상화한 객체를 정의
2. 클라이언트에서 이 객체의 세터 메서드를 호출해 필요한 값을 설정
3. 클라이언트는 먼저 필요한 매개변수를 다 설정한 다음 execute 메서드를 호출해 앞서 설정한 매개변수들의 유효성을 검사
4. 설정이 완료된 객체를 넘겨 원하는 계산 수행

- 매개변수의 타입으로는 클래스보다는 인터페이스가 낫다.
  →매개변수로 적합한 인터페이스가 있다면 그 인터페이스를 직접 사용하자
  →예를 들어, 메서드에 HashMap을 넘기기 대신 Map을 사용하면 HashMap 뿐 아니라 TreeMap, ConcurrentHashMap 등 어떤 Map 구현체도 인수로 건낼 수 있다.

- boolean보다는 원소 2개짜리 열거 타입이 낫다.
  →열거 타입 사용 시 코드를 읽고 쓰기가 더 쉬워진다.
  →나중에 선택지를 추가하기도 쉽다.
  →예제 코드: 화씨온도와 섭씨 온도를 원소로 정의한 열거 타입

    ```java
    public enum TemperatureScale { FAHRENHEIT, CELSIUS }
    ```

  →온도계 클래스의 메서드가 이 열거 타입을 입력받아 적합한 온도계 인스턴스를 생성해준다고 가정
  →열거타입으로 작성시 장점

    1. Thermometer.newlnstance(true)보다 Thermometer.newInstance(TemperatureScale.CELSIUS)가 하는 일을 훨씬 명확히 알려줌
    2. 나중에 캘빈온도도 지원해야한다면, Thermometer에 또 다른 메서드를 추가할 필요 없이 TemperatureScale 열거 타입에 캘빈온도를 추가하면 됨
    3. 온도 단위에 대한 의존성을 개별 열거 타입 상수의 메서드 안으로 리팩터링해 넣을 수 있음
       ( 열거 타입은 단순한 값의 나열이 아니라, 자체적으로 메서드를 가질 수 있기 때문에 가능)